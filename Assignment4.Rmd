---
title: "BME4550_Fall2018_Assignment4"
author: "Monika Grabowska"
date: "September 25, 2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
```

## Chapter 18 - no exercises

## 19.2.1 Practice

###1. Why is `TRUE` not a parameter to `rescale01()`? What would happen if `x` contained a single missing value, and `na.rm` was `FALSE`?

`TRUE` is not a parameter to `rescale01()` because we don’t want it to be a parameter of a function that the user can change. If `x` contains a missing value and `na.rm` is `FALSE` then the output vector will have an NA value. 

###2. In the second variant of `rescale01()`, infinite values are left unchanged. Rewrite `rescale01()` so that -`Inf` is mapped to 0, and `Inf` is mapped to 1.

```{r}
rescale01 <- function(x) {
  rng <- range(x, na.rm = TRUE, finite = TRUE)
  (x - rng[1]) / (rng[2] - rng[1])
  x[x == -Inf] <- 0
  x[x == Inf] <- 1
  return(x)
}
rescale01(c(5,NA,-Inf,10,Inf))
```

###3. Practice turning the following code snippets into functions. Think about what each function does. What would you call it? How many arguments does it need? Can you rewrite it to be more expressive or less duplicative?

```
mean(is.na(x))

x / sum(x, na.rm = TRUE)

sd(x, na.rm = TRUE) / mean(x, na.rm = TRUE)
```

```
prop_NA <- function(x) {
  return(mean(is.na(x)))
}

to_weights <- function(x) {
  x / sum(x, na.rm = TRUE)
}

coeff_var <- function(x) {
  return(sd(x, na.rm = TRUE) / mean(x, na.rm = TRUE))
}
```

###4. Follow http://nicercode.github.io/intro/writing-functions.html to write your own functions to compute the variance and skew of a numeric vector.

```{r}
variance <- function(x) {
  diff_from_mean <- (x - mean(x, rm.na = TRUE))
  sum_of_squares <- sum(diff_from_mean^2, rm.na = TRUE)
  return(sum_of_squares/(sum(!is.na(x)) - 1))
}
variance(c(1,10,12,2))
```

```{r}
skewness <- function(x) {
  diff_from_mean <- (x - mean(x, rm.na = TRUE))
  third_moment <- sum(diff_from_mean^3, na.rm = TRUE)
  std_cubed <- sum(diff_from_mean^2, na.rm = TRUE)^(3/2)/sqrt(sum(!is.na(x)))
  return(third_moment/std_cubed)
}
skewness(c(1,10,12,2))
```

###5. Write `both_na()`, a function that takes two vectors of the same length and returns the number of positions that have an `NA` in both vectors.

```{r}
both_na <- function(x, y){
  x <- is.na(x)
  y <- is.na(y)
  return(sum(x & y))
}
both_na(c(1,NA,NA,NA,5), c(1,NA,7,NA,NA))
```

###6. What do the following functions do? Why are they useful even though they are so short?

```{r}
is_directory <- function(x) file.info(x)$isdir
is_readable <- function(x) file.access(x, 4) == 0
```

`is_directory()` returns `TRUE` if `x` is a directory and `FALSE` otherwise. `is_readable()` returns `TRUE` if a file can be read. They are useful because their function names reveal more about their function than the actual code. 

###7. Read the complete lyrics to “Little Bunny Foo Foo”. There’s a lot of duplication in this song. Extend the initial piping example to recreate the complete song, and use functions to reduce the duplication.

```{r}
foofoo <- function() {
  first <- "Little bunny Foo Foo\nHopping through the forest\nScooping up the field mice\nAnd bopping them on the head"
  second <-"Down came the Good Fairy, and she said\n\"Little bunny Foo Foo\nI don't want to see you\nScooping up the field mice\nAnd bopping them on the head.\""
  cat(second)
  i <- 3
  while(i > 0){
    word <- switch(i,
                   'one',
                   'two',
                   'three'
                   )
    third <- paste0("I'll give you ", word, " chances,\nAnd if you don't behave, I will turn you into a goon!\"\nAnd the next day...")
    cat(first, second, third, sep = "\n\n")
    i <- i - 1
  }
  final <- "I gave you three chances and you didn't behave so....\nPOOF. She turned him into a Goon."
  cat(first, second, final, sep = "\n\n")
  
}
foofoo()
```

## 19.3.1 Exercises

###1. Read the source code for each of the following three functions, puzzle out what they do, and then brainstorm better names.

```{r}
f1 <- function(string, prefix) {
  substr(string, 1, nchar(prefix)) == prefix
}
f2 <- function(x) {
  if (length(x) <= 1) return(NULL)
  x[-length(x)]
}
f3 <- function(x, y) {
  rep(y, length.out = length(x))
}
```

`f1` tests whether each element of the character vector nchar starts with the string prefix. A better name for `f1` would be `has_prefix()`.

`f2` drops the last element of the vector x, thus a better name for `f2` would be `drop_last()`. 

`f3` repeats y once for each element of x. A better name for `f3` would be `repeat_y()`. 

###2. Take a function that you’ve written recently and spend 5 minutes brainstorming a better name for it and its arguments.

Function: analyze_f3, better name would be analyze_pop. Arguments: target population, could call this pop_target.

###3. Compare and contrast `rnorm()` and `MASS::mvrnorm()`. How could you make them more consistent?

`rnorm()` samples from the univariate normal distribution, whereas `MASS::mvrnorm()` samples from the multivariate normal distribution. `rnorm()` takes the arguments n, mean, and sd, whereas `MASS::mvrnorm()` takes the arguments n, mu, and Sigma. To make them more consistent you could make them take arguments with the same names. 

###4. Make a case for why `norm_r()`, `norm_d()` etc would be better than `rnorm()`, `dnorm()`. Make a case for the opposite.

`norm_r()` and `norm_d()` would be better because then the naming convention would group functions by their distribution. However, with `rnorm()` and `dnorm()`, the naming convention would group functions by the action they perform, which is also advantageous. 

## 19.4.4 Exercises

###1. What’s the difference between `if` and `ifelse()`? Carefully read the help and construct three examples that illustrate the key differences.

`if` tests a single condition, whereas `ifelse()` tests each element. 

```{r}
if (TRUE) {
  print("Yes")
} else {
  print("No")
}
```

```{r}
ifelse(c(TRUE, FALSE, FALSE, TRUE), "Yes", "No")
```

###2. Write a greeting function that says “good morning”, “good afternoon”, or “good evening”, depending on the time of day. (Hint: use a time argument that defaults to `lubridate::now()`. That will make it easier to test your function.)

```{r}
greet <- function(time = lubridate::now()) {
  hr <- lubridate::hour(time)
  if (hr < 12) {
    print("good morning")
  } else if (hr < 17) {
    print("good afternoon")
  } else {
    print("good evening")
  }
}
greet()
```

###3. Implement a `fizzbuzz` function. It takes a single number as input. If the number is divisible by three, it returns “fizz”. If it’s divisible by five it returns “buzz”. If it’s divisible by three and five, it returns “fizzbuzz”. Otherwise, it returns the number. Make sure you first write working code before you create the function.

```{r}
fizzbuzz <- function(x) {
  stopifnot(length(x) == 1)
  stopifnot(is.numeric(x))
  if (!(x %% 3) && !(x %% 5)) {
    "fizzbuzz"
  } else if (!(x %% 3)) {
    "fizz"
  } else if (!(x %% 5)) {
    "buzz"
  } else {
    x
  }
}
fizzbuzz(9)
fizzbuzz(15)
fizzbuzz(2)
fizzbuzz(10)
```

###4. How could you use `cut()` to simplify this set of nested if-else statements?

```
if (temp <= 0) {
  "freezing"
} else if (temp <= 10) {
  "cold"
} else if (temp <= 20) {
  "cool"
} else if (temp <= 30) {
  "warm"
} else {
  "hot"
}
```

Using `cut()`: 
```
cut(temp, breaks = seq(-10, 40, 10),
    labels = c("freezing", "cold", "cool", "warm", "hot"))
```

### How would you change the call to `cut()` if I’d used `<` instead of `<=`? What is the other chief advantage of `cut()` for this problem? (Hint: what happens if you have many values in `temp`?)

Changed call to `cut()`:
```
cut(temp, breaks = seq(-10, 40, 10),
    right = FALSE,
    labels = c("freezing", "cold", "cool", "warm", "hot"))
```

The advantages of using `cut()` are that it works on vectors (whereas `if` only works on a single value) and that it is easier to change comparisons using `cut()` (would only need to change the argument to `right` compared to changing four operators if had used `if`). 

###5. What happens if you use `switch()` with numeric values?

```{r}
switch(1, "No", "Yes", "Maybe")
switch(2, "No", "Yes", "Maybe")
```

If you use `switch()` with numeric values (as in `switch(n, ...)`), then it will return the nth argument in ..., as shown above.

###6. What does this `switch()` call do? What happens if x is “e”?

```{r}
x <- "b"
switch(x, 
  a = ,
  b = "ab",
  c = ,
  d = "cd"
)
```

```{r}
x <- "a"
switch(x, 
  a = ,
  b = "ab",
  c = ,
  d = "cd"
)
```

```{r}
x <- "e"
switch(x, 
  a = ,
  b = "ab",
  c = ,
  d = "cd"
)
```

### Experiment, then carefully read the documentation.

If `x` matches one of the elements in the `switch()` call then that element is evaluated unless it is missing, in which case the next non-missing element is evaluated. If `x` does not match one of the elements in the `switch()` call then its original value is returned.

## 19.5.5 Exercises

###1. What does `commas(letters, collapse = "-")` do? Why?

```{r, error = TRUE}
commas <- function(...) {
  stringr::str_c(..., collapse = ", ")
}
commas(letters, collapse = "-")
```

`commas(letters, collapse = "-")` throws an error because the `collapse` argument is passed to `str_c` in the `commas` function, which already has the argument `collapse = ", "`.

You could get letters separated by "-" if you did:
```{r}
commas <- function(..., collapse = ",") {
  str_c(..., collapse = collapse)
}
commas(letters, collapse = "-")
```

###2. It’d be nice if you could supply multiple characters to the `pad` argument, e.g. `rule("Title", pad = "-+")`. Why doesn’t this currently work? How could you fix it?

This doesn't currently work because the original `rule` function copies the `pad` argument a very specific number of times (equal to the desired width minus the length of the title and five extra characters) - if `pad` is 2 characters rather than 1 then the output is almost twice as long. 

Original: 
```{r}
rule <- function(..., pad = "-") {
  title <- paste0(...)
  width <- getOption("width") - nchar(title) - 5
  cat(title, " ", stringr::str_dup(pad, width), "\n", sep = "")
}
rule("Title", pad = "-+")
```

Fixed:
```{r}
rule <- function(..., pad = "-") {
  title <- paste0(...)
  width <- getOption("width") - nchar(title) - 5
  pad_char <- nchar(pad)
  cat(title, " ", stringr::str_dup(pad, width / pad_char), "\n", sep = "")
}
rule("Title", pad = "-+")
```

###3. What does the trim argument to `mean()` do? When might you use it?

The trim argument to `mean()` trims a specified fraction of observations off each end of the vector before calculating the mean. This is useful for excluding outliers.

Example: Trimming 10 percent of observations off each end of the vector
```{r}
mean(c(99, 1:10))
mean(c(99, 1:10), trim = 0.1)
```

###4. The default value for the method argument to `cor()` is `c("pearson", "kendall", "spearman")`. What does that mean? What value is used by default?

That means the method argument can take any one of those 3 values. The default is the first value, i.e. "pearson". 

## 20.3.5 Exercises

###1. Describe the difference between `is.finite(x)` and `!is.infinite(x)`.

```{r}
x <- c(0, NA, NaN, Inf, -Inf)
is.finite(x)
!is.infinite(x)
```

`is.finite(x)` considers non-missing numeric values (ex. 0) to be finite, while values that are missing (NA), not a number (NaN), positive infinity (Inf), or negative infinity (-Inf) are not finite. `!is.finite(x)` considers non-missing numeric, NA, and NaN values to be finite, while Inf and -Inf are not finite. 

###2. Read the source code for `dplyr::near()` (Hint: to see the source code, drop the `()`). How does it work?

```{r}
dplyr::near
```

`dplyr::near()` checks that two numbers are within a certain tolerance (tol). The default value of tol is the square root of .Machine$double.eps. 

###3. A logical vector can take 3 possible values. How many possible values can an integer vector take? How many possible values can a double take? Use google to do some research.

Integer vectors have 32-bit representation in R, thus an integer vector can take 2^32 possible values. Double vectors have 64-bit representation in R, thus a double vector can take 2^64 possible values. 

###4. Brainstorm at least four functions that allow you to convert a double to an integer. How do they differ? Be precise.

```{r}
x <- seq(-5, 5, by = 0.5)
as.integer(x) # coerces its argument to be an integer
floor(x) # rounds down 
ceiling(x) # rounds up 
`%/%`(x, 1) # extracts the integer part of x
```

###5. What functions from the readr package allow you to turn a string into logical, integer, and double vector?

`parse_logical()`, `parse_integer()`, and `parse_double()` allow you to turn a string into a logical, integer, and double vector (see example below). 

```{r}
x <- c("TRUE", "FALSE")
parse_logical(x)
x <- c("1", "2")
parse_integer(x)
x <- c("1.1", "1.2")
parse_double(x)
```

## 20.4.6 Exercises

###1. What does `mean(is.na(x))` tell you about a vector `x`? What about `sum(!is.finite(x))`?

`mean(is.na(x))` gives the proportion of missing values in the vector, while `sum(!is.finite(x))` gives the number of not finite values in the vector. 

###2. Carefully read the documentation of `is.vector()`. What does it actually test for? Why does `is.atomic()` not agree with the definition of atomic vectors above?

`is.vector()` only tests if x is a vector of the specified mode having no attributes other than names. `is.atomic()` tests for the atomic types ("logical", "integer", "numeric", "complex", "character" and "raw") and NULL. 

###3. Compare and contrast `setNames()` with `purrr::set_names()`.

`purrr::set_names()`has more ways to set the names than `setNames()`. Also, with `purrr::set_names()`, you can use a function to transform the existing names.

```{r}
purrr::set_names(c(a = 1, b = 2, c = 3), toupper)
```

###4. Create functions that take a vector as input and returns: 1) The last value. Should you use `[` or `[[`? 2) The elements at even numbered positions. 3) Every element except the last value. 4) Only even numbers (and no missing values).

```{r}
x <- c(-3, -1, 0, 1, 5, 10, NA)
```

1)
```{r}
last_value <- function(x) {
  x[[length(x)]]
}
last_value(x)
```

2)
```{r}
even_positions <- function(x) {
  x[seq(2, length(x), 2)]
}
even_positions(x)
```

3)
```{r}
except_last <- function(x) {
  x[1:(length(x)-1)]
}
except_last(x)
```

4)
```{r}
even_numbers <- function(x) {
  x[x %% 2 == 0 & !is.na(x)]
}
even_numbers(x)
```

###5. Why is `x[-which(x > 0)]` not the same as `x[x <= 0]`?

`x[-which(x > 0)]` and `x[x <= 0]` handle missing values differently. This is because `which()` leaves NA and NaN values alone, while `<=` turns NaN values into NA values. 

```{r}
x <- c(-5:5, Inf, -Inf, NaN, NA)
x[-which(x > 0)]
x[x <= 0]
```

###6. What happens when you subset with a positive integer that’s bigger than the length of the vector? What happens when you subset with a name that doesn’t exist?

If you subset with a positive integer that's bigger than the length of the vector, you get NA for that element. Similarly, when you subset with a name that doesn't exist, you get NA.  

```{r}
x <- c(a = 10, b = 20)
x[3]
x["c"]
```

## 20.5.4 Exercises

###1. Draw the following lists as nested sets: 1) `list(a, b, list(c, d), list(e, f))` 2) `list(list(list(list(list(list(a))))))`

![`list(a, b, list(c, d), list(e, f))`](nested_set_1.png)

![`list(list(list(list(list(list(a))))))`](nested_set_2.png)


###2. What happens if you subset a tibble as if you’re subsetting a list? What are the key differences between a list and a tibble?

Subsetting a tibble and subsetting a list work the same way. The main difference between a list and a tibble is that all columns in a tibble must have the same number of rows, while lists can have vectors with different lengths. 

```{r}
x <- tibble(a = 1:2, b = 3:4)
x[1]
x[[1]]
```

## 20.7.4 Exercises

###1. What does `hms::hms(3600)` return? How does it print? What primitive type is the augmented vector built on top of? What attributes does it use?

```{r}
x <- hms::hms(3600)
typeof(x) 
attributes(x)
```

hms::hms(3600) prints the time (1 o'clock) in hh:mm:ss format. The primitive type is a double. The attributes it uses are `units` and `class`. 

###2. Try and make a tibble that has columns with different lengths. What happens?

```{r, error = TRUE}
tibble(x = 1:3, y = 1:10)
```

###3. Based on the definition above, is it ok to have a list as a column of a tibble?

Yes, it is okay to have a list as a column of a tibble as long as it has the same length as other columns.

```{r}
tibble(x = 1:3, y = list("a", 1, list(1:3)))
```

## 21.2.1 Exercises

###1. Write for loops to: 1) Compute the mean of every column in `mtcars`. 2) Determine the type of each column in `nycflights13::flights`. 3) Compute the number of unique values in each column of `iris`. 4) Generate 10 random normals for each of μ = −10, 0, 10, and 100. Think about the output, sequence, and body before you start writing the loop.

1)
```{r}
mean_col <-  vector("double", ncol(mtcars))
names(mean_col) <-  names(mtcars)
for (i in names(mtcars)) {
  mean_col[[1]] <-  mean(mtcars[[i]])
}
mean_col
```

2)
```{r}
data("flights", package = "nycflights13")
type_col <- vector("list", ncol(flights))
names(type_col) <- names(flights)
for (i in names(flights)) {
  type_col[[i]] <- class(flights[[i]])
}
type_col
```

3)
```{r}
data("iris")
unique_iris <- vector("double", ncol(iris))
names(unique_iris) <- names(iris)
for (i in names(iris)) {
  unique_iris[i] <- length(unique(iris[[i]]))
}
unique_iris
```

4)
```{r}
n <- 10
u <- c(-10, 0, 10, 100)
normals <- vector("list", length(u))
for (i in seq_along(normals)) {
  normals[[i]] <- rnorm(n, mean = u[i])
}
normals
```

###2. Eliminate the for loop in each of the following examples by taking advantage of an existing function that works with vectors:

```{r}
# 1)
out <- ""
for (x in letters) {
  out <- stringr::str_c(out, x)
}
out

# 2) 
x <- sample(100)
sd <- 0
for (i in seq_along(x)) {
  sd <- sd + (x[i] - mean(x)) ^ 2
}
sd <- sqrt(sd / (length(x) - 1))
sd

# 3) 
x <- runif(100)
out <- vector("numeric", length(x))
out[1] <- x[1]
for (i in 2:length(x)) {
  out[i] <- out[i - 1] + x[i]
}
out
```

1)
```{r}
stringr::str_c(letters, collapse = "")
```

2)
```{r}
x <- sample(100)
sd(x)
```

3) 
```{r}
x <- runif(100)
cumsum(x)
```

###3. Combine your function writing and for loop skills: 1) Write a for loop that `prints()` the lyrics to the children’s song “Alice the camel”. 2) Convert the nursery rhyme “ten in the bed” to a function. Generalise it to any number of people in any sleeping structure. 3) Convert the song “99 bottles of beer on the wall” to a function. Generalise to any number of any vessel containing any liquid on any surface.

1) 
```{r}
humps <- c("five", "four", "three", "two", "one", "no")
for (i in humps) {
  cat(str_c("Alice the camel has ", rep(i, 3), " humps.",
             collapse = "\n"), "\n")
  if (i == "no") {
    cat("Now Alice is a horse.\n")
  } else {
    cat("So go, Alice, go.\n")
  }
  cat("\n")
}
```

2)
```{r}
numbers <- c("ten", "nine", "eight", "seven", "six", "five",
             "four", "three", "two", "one")
for (i in numbers) {
  cat(str_c("There were ", i, " in the bed\n"))
  cat("and the little one said\n")
  if (i == "one") {
    cat("I'm lonely...")
  } else {
    cat("Roll over, roll over\n")
    cat("So they all rolled over and one fell out.\n")
  }
  cat("\n")
}
```

3)
```{r}
bottles <- function(i) {
  if (i > 2) {
   bottles <- str_c(i - 1, " bottles")
  } else if (i == 2) {
   bottles <- "1 bottle"
  } else {
   bottles <- "no more bottles"
  }
  bottles
}

beer_bottles <- function(n) {
  # should test whether n >= 1.
  for (i in seq(n, 1)) {
     cat(str_c(bottles(i), " of beer on the wall, ", bottles(i), " of beer.\n"))
     cat(str_c("Take one down and pass it around, ", bottles(i - 1),
                " of beer on the wall.\n\n"))
  }
  cat("No more bottles of beer on the wall, no more bottles of beer.\n")
  cat(str_c("Go to the store and buy some more, ", bottles(n), " of beer on the wall.\n"))
}
beer_bottles(5)
```

###4. It’s common to see for loops that don’t preallocate the output and instead increase the length of a vector at each step:

```
output <- vector("integer", 0)
for (i in seq_along(x)) {
  output <- c(output, lengths(x[[i]]))
}
output
```

### How does this affect performance? Design and execute an experiment.

(Using package `microbenchmark` to time execution of R expressions)
```{r}
library(microbenchmark)
```

No preallocation: 
```{r}
non_allocate <- function(n) {
  output <- vector("integer", 0)
  for (i in seq_len(n)) {
    output <- c(output, i)
  }
  output  
}
microbenchmark(non_allocate(10000), times = 10)
```

With preallocation: 
```{r}
allocate <- function(n) {
  output <- vector("integer", n)
  for (i in seq_len(n)) {
    output[[i]] <- i
  }
  output
}
microbenchmark(allocate(10000), times = 10)
```

Loops that preallocate the output run much faster. 

## 21.3.5 Exercises

###1. Imagine you have a directory full of CSV files that you want to read in. You have their paths in a vector, `files <- dir("data/", pattern = "\\.csv$", full.names = TRUE)`, and now want to read each one with `read_csv()`. Write the for loop that will load them into a single data frame.

```
df <- vector("list", length(files))
for (fname in seq_along(files)) {
  df[[i]] <- read_csv(files[[i]])
}
df <- bind_rows(df)
```

###2. What happens if you use for `(nm in names(x))` and `x` has no names? What if only some of the elements are named? What if the names are not unique?

If `x` has no names, then nothing happens (the loop is run 0 times). If only some of the elements are named, then the empty name is filled with "" and there is an error when trying to access the value of the un-named element. If the names are not unique, then only the first element with the duplicate name is accessed. 

```{r}
x <- 1:5
for (nm in names(x)) {
  print(nm)
  print(x[[nm]])
}
```

```{r, error = TRUE}
x <- c(a = 1, 2, c = 3)
for (nm in names(x)) {
  print(nm)
  print(x[[nm]])
}
```

```{r}
x <- c(a = 1, a = 2, c = 3)
for (nm in names(x)) {
  print(nm)
  print(x[[nm]])
}
```

###3. Write a function that prints the mean of each numeric column in a data frame, along with its name. For example, `show_mean(iris)` would print:

```
show_mean(iris)
#> Sepal.Length: 5.84
#> Sepal.Width:  3.06
#> Petal.Length: 3.76
#> Petal.Width:  1.20
```

```{r}
col_mean <- function(x) {
  classes <- vector("logical", length(x))
  for (i in seq_along(x)) classes[[i]] <- is.numeric(x[[i]])
  x <- x[classes]
  for (i in seq_along(x)) {
    cat(paste0(names(x)[i], ": ", round(mean(x[[i]]), 2)), fill = TRUE)
  }
}
col_mean(iris)
```

### (Extra challenge: what function did I use to make sure that the numbers lined up nicely, even though the variable names had different lengths?)

Used `cat()` `fill = TRUE` to ensure numbers lined up nicely. 

###4. What does this code do? How does it work?

```{r}
trans <- list( 
  disp = function(x) x * 0.0163871,
  am = function(x) {
    factor(x, labels = c("auto", "manual"))
  }
)
for (var in names(trans)) {
  mtcars[[var]] <- trans[[var]](mtcars[[var]])
}
```

This code multiplies `disp` by 0.0163871 and converts `am` into a factor. The code then loops over a named list of functions, calling each function in the list on the corresponding column of `mtcars` and replacing the values in that column. 

## 21.4.1 Exercises

###1. Read the documentation for `apply()`. In the 2d case, what two for loops does it generalise?

It generalizes looping over the rows or columns of an array or matrix. 

###2. Adapt `col_summary()` so that it only applies to numeric columns. You might want to start with an `is_numeric()` function that returns a logical vector that has a TRUE corresponding to each numeric column.

```{r}
col_summary <- function(x) {
  col_numeric <- vector("logical", length(x))
  for (i in seq_along(x)) {
    col_numeric[[i]] <- is.numeric(x[[i]])
  }
  x <- x[col_numeric]
  output <- vector("numeric", length(x))
  for (i in seq_along(x)) {
    output[[i]] <- mean(x[[i]])
  }
  output
}
col_summary(iris)
```

## 21.5.3 Exercises

###1. Write code that uses one of the map functions to: 1) Compute the mean of every column in `mtcars`. 2) Determine the type of each column in `nycflights13::flights`. 3) Compute the number of unique values in each column of `iris`. 4) Generate 10 random normals for each of μ = −10, 0, 10, and 100. 

1) 
```{r}
map_dbl(mtcars, mean)
```

2)
```{r}
map(nycflights13::flights, typeof)
```

3) 
```{r}
map(iris, ~ length(unique(.)))
```

4)
```{r}
map(c(-10, 0, 10, 100), ~ rnorm(n = 10, mean = .))
```

###2. How can you create a single vector that for each column in a data frame indicates whether or not it’s a factor?

```{r}
map_lgl(iris, is.factor)
```

###3. What happens when you use the map functions on vectors that aren’t lists? What does `map(1:5, runif)` do? Why?

```{r}
x <- map(1:5, runif)
x
```

When you use map functions on vectors that aren't lists, then they still iterate over the vector elements. `map(1:5, runif)` is equivalent to running runif(1), runif(2), ..., runif(5), and then collecting the results in a list (end up with a list with five numeric vectors inside of it ranging from size 1 to size 5).

###4. What does `map(-2:2, rnorm, n = 5)` do? Why? What does `map_dbl(-2:2, rnorm, n = 5)` do? Why?

```{r, error = TRUE}
map(-2:2, rnorm, n = 5)
map_dbl(-2:2, rnorm, n = 5)
```

`map(-2:2, rnorm, n = 5)` runs rnorm with mean -2, then -1, ..., 2, returning a list of 5 vectors, each with size 5. On the other hand, `map_dbl(-2:2, rnorm, n = 5)` does the same thing but also checks that the result is of type double and has a length of 1 (throws an error because doesn't have length of 1). 

###5. Rewrite `map(x, function(df) lm(mpg ~ wt, data = df))` to eliminate the anonymous function.

```
map(x, ~ lm(mpg ~ wt, data = .))
```

## 21.9.3 Exercises

###1. Implement your own version of `every()` using a for loop. Compare it with `purrr::every()`. What does purrr’s version do that your version doesn’t?

```{r}
every_2 <- function(.x, .p, ...) {
  for (i in .x) {
    if (!.p(i, ...)) {
      return(FALSE)
    }
  }
  TRUE  
}

every_2(1:5, function(x) {x > 1})
```

purrr's version is able to do more things with .p (ex. taking a logical vector) and probably runs faster. 

###2. Create an `enhanced col_sum()` that applies a summary function to every numeric column in a data frame.

```{r}
enhanced_col_sum <- function(df, f, ...) {
  map(keep(df, is.numeric), f, ...)
}
enhanced_col_sum(iris, mean)
```

###3. A possible base R equivalent of `col_sum()` is:

```{r}
col_sum3 <- function(df, f) {
  is_num <- sapply(df, is.numeric)
  df_num <- df[, is_num]

  sapply(df_num, f)
}
```

### But it has a number of bugs as illustrated with the following inputs:

```{r, error = TRUE}
df <- tibble(
  x = 1:3, 
  y = 3:1,
  z = c("a", "b", "c")
)
col_sum3(df, mean)
# Has problems: don't always return numeric vector
col_sum3(df[1:2], mean)
col_sum3(df[1], mean)
col_sum3(df[0], mean)
```

### What causes the bugs?

The bugs are caused by the fact that `sapply` does not always produce the same type of output - for example, `sapply(df[0], is.numeric)` returns a named list while `sapply(df[1], is.numeric)` returns a logical vector.

```{r}
x <- sapply(df[0], is.numeric)
typeof(x)

y <- sapply(df[1], is.numeric)
typeof(y)
```
